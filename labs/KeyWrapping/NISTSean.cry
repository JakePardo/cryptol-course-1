module labs::KeyWrapping::NISTSean where

import specs::Primitive::Symmetric::Cipher::Block::AES128 as AES128
import specs::Primitive::Symmetric::Cipher::Block::AES192 as AES192
import specs::Primitive::Symmetric::Cipher::Block::AES256 as AES256

/**
 * This algorithm specifies the wrapping function, W, for KW-AE (see
 * Sec. 6.2) and KWP-AE (see Sec. 6.3), using the same KEK and
 * designated cipher function.
 *
 * Prerequisites: KEK, K, for an approved, 128-bit block cipher;
 * designated cipher function, CIPHK. This necessarily implies that a
 * semiblock is 64-bits.
 *
 * Input: a string, S, of n semiblocks, for some integer n ≥ 3.
 **/

W :
    {n}
    (fin n, n >= 3, 64 >= width (6 * (n - 1))) =>
    ([128] -> [128]) -> [n][64] -> [n][64]
W CIPHk S = C
  where
    t = [ 1 .. 6*(n-1) ]
    C = foldl (WStep CIPHk) S t

/**
 * This algorithm implements step 2 of W, the inner loop that
 * calculates the intermediate values At and Rt.
 */

WStep :
    {n}
    (fin n, n >= 3) =>
    ([128] -> [128]) -> [n][64] -> [64] -> [n][64]
WStep CIPHk ([At] # Rt) t = ([At' ^ t] # Rt')
  where
    [At', Rtn] = split (CIPHk (At # head Rt))
    Rt'        = tail Rt # [Rtn]

/**
 * This algorithm specifies the authenticated-encryption function for
 * KW for a given block cipher and KEK. The wrapping function, W,
 * specified in the algorithm above, is invoked in Step 3 with the same
 * block cipher and KEK as prerequisites.
 *
 * Prerequisites: KEK, K, for an approved, 128-bit block cipher;
 * designated cipher function, CIPHK; definition of valid plaintext
 * lengths.
 *
 * Input: plaintext P, with valid length n.
 *
 * Output: ciphertext C.
 */

KW :
    {n}
    (fin n, n >= 2, 64 >= width (6 * n)) =>
    ([128] -> [128]) -> [n][64] -> [n+1][64]
KW CIPHk P = C
  where
    ICV1 = 0xA6A6A6A6A6A6A6A6
    S = [ICV1] # P
    C = W CIPHk S






/**
 * This algorithm specifies the wrapping function, W, for KW-AE (see
 * Sec. 6.2) and KWP-AE (see Sec. 6.3), using the same KEK and
 * designated cipher function.
 *
 * Prerequisites: KEK, K, for an approved, 128-bit block cipher;
 * designated cipher function, CIPHK. This necessarily implies that a
 * semiblock is 64-bits.
 *
 * Input: a string, S, of n semiblocks, for some integer n ≥ 3.
 **/

WInv :
    {n}
    (fin n, n >= 3, 64 >= width (6 * (n - 1))) =>
    ([128] -> [128]) -> [n][64] -> [n][64]
WInv CIPHk C = S
  where
    t = [ 1 .. 6*(n-1) ]
    S = foldl (WInvStep CIPHk) C t

/**
 * This algorithm implements step 2 of W, the inner loop that
 * calculates the intermediate values At and Rt.
 */

WInvStep :
    {n}
    (fin n, n >= 3) =>
    ([128] -> [128]) -> [n][64] -> [64] -> [n][64]
WInvStep CIPHk ([At] # Rt) t = ([At'] # Rt')
  where
    [At', Rt2] = split (CIPHk ((At ^ t) # (last Rt)))
    Rt'        = [Rt2] # (take`{n-2} Rt)

/**
 * This algorithm specifies the authenticated-encryption function for
 * KW for a given block cipher and KEK. The wrapping function, W,
 * specified in the algorithm above, is invoked in Step 3 with the same
 * block cipher and KEK as prerequisites.
 *
 * Prerequisites: KEK, K, for an approved, 128-bit block cipher;
 * designated cipher function, CIPHK; definition of valid plaintext
 * lengths.
 *
 * Input: plaintext P, with valid length n.
 *
 * Output: ciphertext C.
 */

KWInv :
    {n}
    (fin n, n >= 2, 64 >= width (6 * n)) =>
    ([128] -> [128]) -> [n+1][64] -> [n+1][64]
KWInv CIPHk C = P
  where
    ICV1 = 0xA6A6A6A6A6A6A6A6
    P = WInv CIPHk C
    


Test_128_128 : [128] -> [128] -> [192]
Test_128_128 k pt = join ct
  where
    ct = KW (\p -> AES128::aesEncrypt (p, k)) (split pt)
    
TestVector_1_Key = join [ 0x0001020304050607, 
                          0x08090A0B0C0D0E0F ]
TestVector_1_PT  = join [ 0x0011223344556677, 
                          0x8899AABBCCDDEEFF ]
TestVector_1_CT  = join [ 0x1fa68b0a8112b447, 
                          0xaef34bd8fb5a7b82,
                          0x9d3e862371d2cfe5 ]
  
property RFC3394_TestVector_1 = 
  Test_128_128 TestVector_1_Key TestVector_1_PT == TestVector_1_CT
  
    
    
Test_192_128 : [192] -> [128] -> [192]
Test_192_128 k pt = join ct
  where
    ct = KW (\p -> AES192::aesEncrypt (p, k)) (split pt)

TestVector_2_Key = join [ 0x0001020304050607, 
                          0x08090A0B0C0D0E0F,
                          0x1011121314151617 ]
TestVector_2_PT  = join [ 0x0011223344556677, 
                          0x8899AABBCCDDEEFF ]
TestVector_2_CT  = join [ 0x96778b25ae6ca435,
                          0xf92b5b97c050aed2,
                          0x468ab8a17ad84e5d ]

property RFC3394_TestVector_2 = 
  Test_192_128 TestVector_2_Key TestVector_2_PT == TestVector_2_CT



Test_256_128 : [256] -> [128] -> [192]
Test_256_128 k pt = join ct
  where
    ct = KW (\p -> AES256::aesEncrypt (p, k)) (split pt)

TestVector_3_Key = join [ 0x0001020304050607,
                          0x08090A0B0C0D0E0F,
                          0x1011121314151617,
                          0x18191A1B1C1D1E1F ]
TestVector_3_PT  = join [ 0x0011223344556677, 
                          0x8899AABBCCDDEEFF ]
TestVector_3_CT  = join [ 0x64e8c3f9ce0f5ba2,
                          0x63e9777905818a2a,
                          0x93c8191e7d6e8ae7 ]
    
property RFC3394_TestVector_3 = 
  Test_256_128  TestVector_3_Key TestVector_3_PT== TestVector_3_CT    
    
    

Test_192_192 : [192] -> [192] -> [256]
Test_192_192 k pt = join ct
  where
    ct = KW (\p -> AES192::aesEncrypt (p, k)) (split pt)

TestVector_4_Key = join [ 0x0001020304050607,
                          0x08090A0B0C0D0E0F,
                          0x1011121314151617 ]
TestVector_4_PT  = join [ 0x0011223344556677,
                          0x8899AABBCCDDEEFF,
                          0x0001020304050607 ]
TestVector_4_CT  = join [ 0x031d33264e15d332,
                          0x68f24ec260743edc,
                          0xe1c6c7ddee725a93,
                          0x6ba814915c6762d2 ]

property RFC3394_TestVector_4 = 
  Test_192_192 TestVector_4_Key TestVector_4_PT == TestVector_4_CT



Test_256_192 : [256] -> [192] -> [256]
Test_256_192 k pt = join ct
  where
    ct = KW (\p -> AES256::aesEncrypt (p, k)) (split pt)

TestVector_5_Key = join [ 0x0001020304050607,
                          0x08090A0B0C0D0E0F,
                          0x1011121314151617,
                          0x18191A1B1C1D1E1F ]
TestVector_5_PT  = join [ 0x0011223344556677,
                          0x8899AABBCCDDEEFF,
                          0x0001020304050607 ]
TestVector_5_CT  = join [ 0xa8f9bc1612c68b3f,
                          0xf6e6f4fbe30e71e4,
                          0x769c8b80a32cb895,
                          0x8cd5d17d6b254da1 ]

property RFC3394_TestVector_5 = 
  Test_256_192 TestVector_5_Key TestVector_5_PT == TestVector_5_CT


Test_256_256 : [256] -> [256] -> [320]
Test_256_256 k pt = join ct
  where
    ct = KW (\p -> AES256::aesEncrypt (p, k)) (split pt)

TestVector_6_Key = join [ 0x0001020304050607,
                          0x08090A0B0C0D0E0F,
                          0x1011121314151617,
                          0x18191A1B1C1D1E1F ]
TestVector_6_CT  = join [ 0x0011223344556677,
                          0x8899AABBCCDDEEFF,
                          0x0001020304050607,
                          0x08090A0B0C0D0E0F ]
TestVector_6_PT  = join [ 0x28c9f404c4b810f4,
                          0xcbccb35cfb87f826,
                          0x3f5786e2d80ed326,
                          0xcbc7f0e71a99f43b,
                          0xfb988b9b7a02dd21 ]

property RFC3394_TestVector_6 = 
  Test_256_256 TestVector_6_Key TestVector_6_CT == TestVector_6_PT

