module labs::KeyWrapping::NISTSean where

import specs::Primitive::Symmetric::Cipher::Block::AES_parameterized as AES
import specs::Primitive::Symmetric::Cipher::Block::TripleDES as TDEA

WStepT :
    {n}
    (fin n, n >= 3) =>
    ([128] -> [128]) -> [n][64] -> [64] -> [n][64]
WStepT CIPHk ([A] # Rs) t = [A'] # Rs'
  where
    [MSB, LSB] = split (CIPHk (FIXME_1) )
    A'         = FIXME_2
    Rs'        = FIXME_3
    FIXME_1 = zero
    FIXME_2 = zero
    FIXME_3 = zero

/**
 * This algorithm specifies the wrapping function, W, for KW-AE (see
 * Sec. 6.2) and KWP-AE (see Sec. 6.3), using the same KEK and
 * designated cipher function.
 *
 * Prerequisites: KEK, K, for an approved, 128-bit block cipher;
 * designated cipher function, CIPHK. This necessarily implies that a
 * semiblock is 64-bits.
 *
 * Input: a string, S, of n semiblocks, for some integer n >= 3.
 **/

W :
    {n}
    (fin n, n >= 3, 64 >= width (6 * (n - 1))) =>
    ([128] -> [128]) -> [n][64] -> [n][64]
W CIPHk S = C
  where
    type s = 6*(n-1)
    t = [ 1 .. s ]
    C = foldl (WStep CIPHk) S t

/**
 * This algorithm implements step 2 of W, the inner loop that
 * calculates the intermediate values of A and the R sequence.
 * See Figure 2 on page 12 for a corresponding picture.
 */

WStep :
    {n}
    (fin n, n >= 3) =>
    ([128] -> [128]) -> [n][64] -> [64] -> [n][64]
WStep CIPHk ([A] # Rs) t = [A'] # Rs'
  where
    [MSB, LSB] = split (CIPHk (A # head Rs))
    A'         = MSB ^ t
    Rs'        = tail Rs # [LSB]

/**
 * This algorithm specifies the wrapping function, W', for KW-AD (see
 * Sec. 6.2) and KWP-AD (see Sec. 6.3), with a given block cipher and KEK.
 *
 * Prerequisites: KEK, K, for an approved, 128-bit block cipher;
 * inverse of the designated cipher function, CIPHK'. This necessarily
 * implies that a semiblock is 64-bits.
 *
 * Input: a string, C, of n semiblocks, for some integer n >= 3.
 **/

W' :
    {n}
    (fin n, n >= 3, 64 >= width (6 * (n - 1))) =>
    ([128] -> [128]) -> [n][64] -> [n][64]
W' CIPHk' C = S
  where
    type s = 6*(n-1)
    t = [ s, s-1 .. 1 ]
    S = foldl (WStep' CIPHk') C t

/**
 * This algorithm implements step 2 of W', the inner loop that
 * calculates the intermediate values of A and the R sequence.
 * See Figure 3 on page 13 for a corresponding picture.
 */

WStep' :
    {n}
    (fin n, n >= 3) =>
    ([128] -> [128]) -> [n][64] -> [64] -> [n][64]
WStep' CIPHk' ([A] # Rs) t = [A'] # Rs'
  where
    [MSB, LSB] = split (CIPHk' ((A ^ t) # last Rs))
    A'         = MSB
    Rs'        = [LSB] # take Rs

/**
 * This is a property to help show that WStep and WStep' are inverses.
 */

property WStepInvProp ARs t =
    WStep'`{3} (\a -> a-1) (WStep (\a -> a+1) ARs t) t == ARs

/**
 * This is a property to help show that W and W' are inverses.
 */
 
property WInvProp S =
    W'`{3} (\a -> a-1) (W (\a -> a+1) S) == S

/**
 * This algorithm specifies the authenticated-encryption function for
 * KW for a given block cipher and KEK. The wrapping function, W,
 * specified in the algorithm above, is invoked in Step 3 with the same
 * block cipher and KEK as prerequisites.
 *
 * Prerequisites: KEK, K, for an approved, 128-bit block cipher;
 * designated cipher function, CIPHk; definition of valid plaintext
 * lengths.
 *
 * Input: plaintext P, with valid length n.
 *
 * Output: ciphertext C.
 */

KWAE :
    {n}
    (fin n, n >= 2, 64 >= width (6 * n)) =>
    ([128] -> [128]) -> [n][64] -> [n+1][64]
KWAE CIPHk P = C
  where
    ICV1 = 0xA6A6A6A6A6A6A6A6
    S = [ICV1] # P
    C = W CIPHk S

/**
 * This algorithm specifies the authenticated-decryption function for
 * KW for a given block cipher and KEK. The wrapping function, W',
 * specified in the algorithm above, is invoked in Step 4 with the same
 * block cipher and KEK as prerequisites.
 *
 * Prerequisites: KEK, K, for an approved, 128-bit block cipher;
 * designated cipher function, CIPHk'; definition of valid ciphertext
 * lengths.
 *
 * Input: purported ciphertext C, with valid length n.
 *
 * Output: plaintext P or indication of inauthenticity, FAIL.
 */

KWAD :
    {n}
    (fin n, n >= 3, 64 >= width (6 * (n-1))) =>
    ([128] -> [128]) -> [n][64] -> (Bit, [n-1][64])
KWAD CIPHk' C = (FAIL, P)
  where
    ICV1 = 0xA6A6A6A6A6A6A6A6
    S = W' CIPHk' C
    FAIL = ICV1 != head S
    P = tail S

/**
 * This is a property to help show that KWAE and KWAD are inverses.
 */

property KWAEInvProp S = 
    KWAD`{3} (\a -> a-1) (KWAE (\a -> a+1) S) == (False, S)

//KW with AES128
KWAE128 (k : [128]) pt = join (KWAE`{2} (AES::encrypt k) (split pt))

KWAD128 (k : [128]) ct = (FAIL, join pt)
  where (FAIL, pt) = KWAD`{3} (AES::decrypt k) (split ct)

property KWAE128Test = KWAD128 1234 (KWAE128 1234 5678) == (False, 5678)


//KW with AES192
KWAE192 (k : [192]) pt = join (KWAE`{3} (AES::encrypt k) (split pt))

KWAD192 (k : [192]) ct = (FAIL, join pt)
  where (FAIL, pt) = KWAD`{4} (AES::decrypt k) (split ct)

property KWAE192Test = KWAD192 1234 (KWAE192 1234 5678) == (False, 5678)

//KW with AES256
KWAE256 (k : [256]) pt = join (KWAE`{4} (AES::encrypt k) (split pt))

KWAD256 (k : [256]) ct = (FAIL, join pt)
  where (FAIL, pt) = KWAD`{5} (AES::decrypt k) (split ct)

property KWAE256Test = KWAD256 1234 (KWAE256 1234 5678) == (False, 5678)


Test_128_128 : [128] -> [128] -> [192]
Test_128_128 k pt = join ct
  where
    ct = KWAE (\p -> AES::encrypt k p) (split pt)
    
TestVector_1_Key = join [ 0x0001020304050607, 
                          0x08090A0B0C0D0E0F ]
TestVector_1_PT  = join [ 0x0011223344556677, 
                          0x8899AABBCCDDEEFF ]
TestVector_1_CT  = join [ 0x1fa68b0a8112b447, 
                          0xaef34bd8fb5a7b82,
                          0x9d3e862371d2cfe5 ]
  
property RFC3394_TestVector_1 = 
  Test_128_128 TestVector_1_Key TestVector_1_PT == TestVector_1_CT
  
    
    
Test_192_128 : [192] -> [128] -> [192]
Test_192_128 k pt = join ct
  where
    ct = KWAE (\p -> AES::encrypt k p) (split pt)

TestVector_2_Key = join [ 0x0001020304050607, 
                          0x08090A0B0C0D0E0F,
                          0x1011121314151617 ]
TestVector_2_PT  = join [ 0x0011223344556677, 
                          0x8899AABBCCDDEEFF ]
TestVector_2_CT  = join [ 0x96778b25ae6ca435,
                          0xf92b5b97c050aed2,
                          0x468ab8a17ad84e5d ]

property RFC3394_TestVector_2 = 
  Test_192_128 TestVector_2_Key TestVector_2_PT == TestVector_2_CT



Test_256_128 : [256] -> [128] -> [192]
Test_256_128 k pt = join ct
  where
    ct = KWAE (\p -> AES::encrypt k p) (split pt)

TestVector_3_Key = join [ 0x0001020304050607,
                          0x08090A0B0C0D0E0F,
                          0x1011121314151617,
                          0x18191A1B1C1D1E1F ]
TestVector_3_PT  = join [ 0x0011223344556677, 
                          0x8899AABBCCDDEEFF ]
TestVector_3_CT  = join [ 0x64e8c3f9ce0f5ba2,
                          0x63e9777905818a2a,
                          0x93c8191e7d6e8ae7 ]
    
property RFC3394_TestVector_3 = 
  Test_256_128  TestVector_3_Key TestVector_3_PT== TestVector_3_CT    
    
    

Test_192_192 : [192] -> [192] -> [256]
Test_192_192 k pt = join ct
  where
    ct = KWAE (\p -> AES::encrypt k p) (split pt)

TestVector_4_Key = join [ 0x0001020304050607,
                          0x08090A0B0C0D0E0F,
                          0x1011121314151617 ]
TestVector_4_PT  = join [ 0x0011223344556677,
                          0x8899AABBCCDDEEFF,
                          0x0001020304050607 ]
TestVector_4_CT  = join [ 0x031d33264e15d332,
                          0x68f24ec260743edc,
                          0xe1c6c7ddee725a93,
                          0x6ba814915c6762d2 ]

property RFC3394_TestVector_4 = 
  Test_192_192 TestVector_4_Key TestVector_4_PT == TestVector_4_CT



Test_256_192 : [256] -> [192] -> [256]
Test_256_192 k pt = join ct
  where
    ct = KWAE (\p -> AES::encrypt k p) (split pt)

TestVector_5_Key = join [ 0x0001020304050607,
                          0x08090A0B0C0D0E0F,
                          0x1011121314151617,
                          0x18191A1B1C1D1E1F ]
TestVector_5_PT  = join [ 0x0011223344556677,
                          0x8899AABBCCDDEEFF,
                          0x0001020304050607 ]
TestVector_5_CT  = join [ 0xa8f9bc1612c68b3f,
                          0xf6e6f4fbe30e71e4,
                          0x769c8b80a32cb895,
                          0x8cd5d17d6b254da1 ]

property RFC3394_TestVector_5 = 
  Test_256_192 TestVector_5_Key TestVector_5_PT == TestVector_5_CT


Test_256_256 : [256] -> [256] -> [320]
Test_256_256 k pt = join ct
  where
    ct = KWAE (\p -> AES::encrypt k p) (split pt)

TestVector_6_Key = join [ 0x0001020304050607,
                          0x08090A0B0C0D0E0F,
                          0x1011121314151617,
                          0x18191A1B1C1D1E1F ]
TestVector_6_CT  = join [ 0x0011223344556677,
                          0x8899AABBCCDDEEFF,
                          0x0001020304050607,
                          0x08090A0B0C0D0E0F ]
TestVector_6_PT  = join [ 0x28c9f404c4b810f4,
                          0xcbccb35cfb87f826,
                          0x3f5786e2d80ed326,
                          0xcbc7f0e71a99f43b,
                          0xfb988b9b7a02dd21 ]

property RFC3394_TestVector_6 = 
  Test_256_256 TestVector_6_Key TestVector_6_CT == TestVector_6_PT



